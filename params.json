{
  "name": "Codi.vim",
  "tagline": "The interactive scratchpad for hackers.",
  "body": "# codi.vim [![Gitter](https://badges.gitter.im/codi-vim/Lobby.svg)](https://gitter.im/codi-vim/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\r\n\r\nThe interactive scratchpad for hackers.\r\n\r\n![Codi Demo](https://ptpb.pw/TsaW.gif)\r\n\r\n_Using Codi as a Python scratchpad through the\r\n[shell wrapper](#shell-wrapper)_\r\n\r\nCodi is an interactive scratchpad for hackers, with a similar interface to\r\n[Numi](https://numi.io). It opens a pane synchronized to your main buffer\r\nwhich displays the results of evaluating each line *as you type* (with NeoVim\r\nor Vim with `+job` and `+channel`, asynchronously). It's extensible to nearly\r\nany language that provides a REPL (interactive interpreter)!\r\n\r\nLanguages with built-in support:\r\nPython, JavaScript, CoffeeScript, Haskell, Ruby, OCaml, R, Clojure/ClojureScript\r\n\r\n[Pull requests](https://github.com/metakirby5/codi.vim/pulls)\r\nfor new language support welcome!\r\n\r\n*Note:* without async support, evaluation will trigger on cursor hold rather\r\nthan text change.\r\n\r\nFor more information, check out the [documentation](doc/codi.txt).\r\nWatch a [screencast](https://ptpb.pw/t/~codi)!\r\n\r\n## Installation\r\n\r\nUse your favorite package manager\r\n([vim-plug](https://github.com/junegunn/vim-plug),\r\n[Vundle](https://github.com/VundleVim/Vundle.vim),\r\n[pathogen.vim](https://github.com/tpope/vim-pathogen)),\r\nor add this directory to your Vim runtime path.\r\n\r\nFor example, if you're using vim-plug, add the following line to `~/.vimrc`:\r\n\r\n```\r\nPlug 'metakirby5/codi.vim'\r\n```\r\n\r\n### Dependencies\r\n\r\n- OS X or Linux (Windows support coming\r\n  [soon](https://github.com/metakirby5/codi.vim/issues/14)!)\r\n- Vim 7.4 (with `+job` and `+channel` for asynchronous evaluation) or\r\n  NeoVim (still in its infancy - please report bugs!)\r\n- `uname`\r\n- If not using NeoVim, `script` (BSD or Linux, man page should say at least\r\n  2013)\r\n\r\nEach interpreter also depends on its REPL. These are loaded on-demand. For\r\nexample, if you only want to use the Python Codi interpreter, you will not\r\nneed `ghci`.\r\n\r\nDefault interpreter dependencies:\r\n\r\n  - Python:       `python`\r\n  - JavaScript:   `node`\r\n  - CoffeeScript: `coffee`\r\n  - Haskell:      `ghci` (be really careful with lazy evaluation!)\r\n  - Ruby:         `irb`\r\n  - OCaml:        `ocaml`\r\n  - R:            `R`\r\n  - Clojure:      `planck`\r\n\r\n## Usage\r\n\r\n- `Codi [filetype]` activates Codi for the current buffer, using the provided\r\n  filetype or the buffer's filetype.\r\n- `Codi!` deactivates Codi for the current buffer.\r\n- `Codi!! [filetype]` toggles Codi for the current buffer.\r\n\r\n### Shell wrapper\r\n\r\nA nice way to use Codi is through a shell wrapper that you can stick in your\r\n`~/.bashrc`:\r\n\r\n```sh\r\n# Codi\r\n# Usage: codi [filetype] [filename]\r\ncodi() {\r\n  local syntax=\"${1:-python}\"\r\n  shift\r\n  vim -c \\\r\n    \"let g:startify_disable_at_vimenter = 1 |\\\r\n    set bt=nofile ls=0 noru nonu nornu |\\\r\n    hi ColorColumn ctermbg=NONE |\\\r\n    hi VertSplit ctermbg=NONE |\\\r\n    hi NonText ctermfg=0 |\\\r\n    Codi $syntax\" \"$@\"\r\n}\r\n```\r\n\r\n### Options\r\n\r\n- `g:codi#interpreters` is a list of user-defined interpreters.\r\n  See the [documentation](doc/codi.txt) for more information.\r\n- `g:codi#aliases` is a list of user-defined interpreter filetype aliases.\r\n  See the [documentation](doc/codi.txt) for more information.\r\n\r\nThe below options can also be set on a per-interpreter basis via\r\n`g:codi#interpreters`:\r\n\r\n- `g:codi#autocmd` determines what autocommands trigger updates.\r\n  See the [documentation](doc/codi.txt) for more information.\r\n- `g:codi#width` is the width of the Codi split.\r\n- `g:codi#rightsplit` is whether or not Codi spawns on the right side.\r\n- `g:codi#rightalign` is whether or not to right-align the Codi buffer.\r\n- `g:codi#autoclose` is whether or not to close Codi when the associated\r\n  buffer is closed.\r\n- `g:codi#raw` is whether or not to display interpreter results without\r\n  alignment formatting (useful for debugging).\r\n- `g:codi#sync` is whether or not to force synchronous execution. No reason to\r\n  touch this unless you want to compare async to sync.\r\n\r\n### Autocommands\r\n\r\n- `CodiEnterPre`, `CodiEnterPost`: When a Codi pane enters.\r\n- `CodiUpdatePre`, `CodiUpdatePost`: When a Codi pane updates.\r\n- `CodiLeavePre`, `CodiLeavePost`: When a Codi pane leaves.\r\n\r\n## FAQ\r\n\r\n- _Why doesn't X work in Codi, when it works in a normal source file?_\r\n  - Codi is not meant to be a replacement for actually running your program;\r\n    it supports nothing more than what the underlying REPL supports. This is\r\n    why Haskell language pragmas don't work and OCaml statements must end with\r\n    `;;`.\r\n\r\n## Thanks to\r\n\r\n- [@DanielFGray](https://github.com/DanielFGray) and\r\n  [@purag](https://github.com/purag) for testing, feedback, and suggestions\r\n- [@Joaquin-V](https://github.com/Joaquin-V) for helping me discover critical\r\n  bugs with vanilla settings\r\n- Everyone who has reported an issue or sent in a pull request :)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}